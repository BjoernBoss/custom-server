<!DOCTYPE html>
<html lang="en" style="margin: 0; height: 100%;">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Editor</title>
</head>

<body contenteditable="false"
	style="display: flex; justify-content: center; margin: 0; height: 100%; align-items: center;">
	<!-- dimension screen -->
	<div id="dimensions"
		style="background-color: #00000040; width: 100%; height: 100%; position: absolute; display: flex; justify-content: center; align-items: center; z-index: 1;">
		<div
			style="border-radius: 6px; border-width: 1px; border-style: solid; border-color: #202020; padding:20px; background-color: #f0f0f0; display: inline-flex; flex-direction: column;">
			<div
				style="margin-bottom: 10px; font-size: 1.75em; font-weight: 500; text-align: center; font-family: system-ui;">
				Dimensions</div>
			<div style="display: flex; margin-bottom: 10px;">
				<input type="number" placeholder="Width" id="width"
					style="width: 150px; font-size: 1.3em; padding: 4px;" min="1" max="64" value="15">
				<div style="font-size: 2em; padding: 0px 10px;">&times;</div>
				<input type="number" placeholder="Height" id="height"
					style="width: 150px; font-size: 1.3em; padding: 4px;" min="1" max="64" value="15">
			</div>
			<div style="display: flex; justify-content: center;">
				<button style="font-size: 1.3em; width: 150px;" onclick="_state.setup()">Create</button>
			</div>
		</div>
	</div>

	<!-- editor view -->
	<div id="editor" style="display: flex; flex-direction: column; width: 100%; height: 100%;">
		<!-- editor caption -->
		<div
			style="background-color: #c0c0c0; display: flex; align-items: center; width: 100%; padding: 20px; justify-content: space-between; box-sizing: border-box; border-style: solid; border-color: #202020; border-width: 0 0 2px 0;">
			<div id="caption" style="font-size: 1.75em; font-weight: 600; font-family: system-ui; margin-right: 20px;">
				Creating Crossword of Size:
			</div>
			<button style="width: 100px; height: 40px; font-size: 1.3em;" onclick="_state.finish();">Finish</button>
		</div>

		<!-- editor view -->
		<div style="flex: 1; background-color: #f0f0f0; overflow: hidden; position: relative; user-select: none;"
			id="container">
			<div style="background-color: #ffffff; border-width: 4px; border-color: #000000; border-style: solid; transform-origin: top left; width: fit-content;"
				id="content">
			</div>
		</div>

		<!-- editor footer -->
		<div
			style="background-color: #c0c0c0; display: flex; align-items: center; width: 100%; padding: 20px; justify-content: space-between; box-sizing: border-box;">
			<div style="font-family: system-ui;">
				Note: Numbers are automatically assigned. Should they not match, please open issue on github.
			</div>
		</div>
	</div>

	<!-- finalize screen -->
	<div id="finalize"
		style="background-color: #00000040; width: 100%; height: 100%; position: absolute; display: none; justify-content: center; align-items: center; z-index: 1;">
		<div
			style="border-radius: 6px; border-width: 1px; border-style: solid; border-color: #202020; padding:20px; background-color: #f0f0f0; display: inline-flex; flex-direction: column;">
			<div
				style="margin-bottom: 10px; font-size: 1.75em; font-weight: 500; text-align: center; font-family: system-ui;">
				Upload Crossword
			</div>
			<input placeholder="Name" id="name" style="width: 300px; font-size: 1.3em; padding: 4px;">
			<div id="error" style="display: none; font-size: 0.75em; color: #b30000; font-family: system-ui;">
				Error Message
			</div>
			<div style="margin-top: 10px; display: flex; align-items: center; justify-content: space-between;">
				<div style="display: flex; justify-content: center;">
					<button style="font-size: 1.3em; width: 150px;" onclick="_state.upload()">Upload</button>
				</div>
				<div style="display: flex; justify-content: center;">
					<button style="font-size: 1.3em; width: 150px;" onclick="_state.cancel()">Cancel</button>
				</div>
			</div>
		</div>
	</div>
</body>

</html>

<style>
	.row-style {
		display: flex;
		flex-direction: row;
	}

	.cell-style {
		width: 48px;
		height: 64px;
		border-color: #e0e0e0;
		border-style: solid;
		border-width: 1px;
		font-size: 1.3em;
		font-family: system-ui;
		font-weight: 500;
		color: #c0c0c0;
		padding: 0px 8px;
	}

	.cell-style.solid {
		background-color: #000000;
		border-color: #000000;
	}
</style>

<script>
	let _state = { uploading: false };
	_state.setup = function () {
		/* validate the dimension */
		_state.width = parseInt(document.getElementById('width').value);
		_state.height = parseInt(document.getElementById('height').value);
		if (!isFinite(_state.width) || !isFinite(_state.height) || _state.width < 0 || _state.width > 64 || _state.height < 0 || _state.height > 64) {
			alert("Invalid dimensions specified");
			return;
		}

		/* lock the input page */
		document.getElementById('dimensions').style.display = 'none';

		/* setup the editor */
		document.getElementById('caption').innerText += ` [${_state.width} \u00d7 ${_state.height}]`;

		/* create the grid object */
		_state.grid = new Array(_state.width);
		for (let x = 0; x < _state.width; ++x) {
			_state.grid[x] = new Array(_state.height);
			for (let y = 0; y < _state.height; ++y)
				_state.grid[x][y] = { solid: false, html: null };
		}

		/* create the separate cells */
		_state.container = document.getElementById('container');
		_state.content = document.getElementById('content');
		for (let y = 0; y < _state.height; ++y) {
			let row = document.createElement('div');
			row.classList.add(['row-style']);
			_state.content.appendChild(row);

			/* add all of the cells */
			for (let x = 0; x < _state.width; ++x) {
				let cell = document.createElement('div');
				cell.classList.add(['cell-style']);
				row.appendChild(cell);

				/* write the cell to the grid object */
				_state.grid[x][y].html = cell;
			}
		}

		/* digitize the new grid (to add all indices) */
		_state.digitize();

		/* setup the viewport */
		_state.view = { scale: 1, pos: [0, 0] };
		_state.updateView();
		new ResizeObserver(() => _state.updateView()).observe(_state.container);

		/* register the event listeners for updating the grid (by left-click/single touch) */
		_state.updating = null;
		_state.content.addEventListener('mousedown', function (e) {
			if (e.button == 0 && _state.startToggle(e.clientX, e.clientY)) {
				e.preventDefault();
				e.stopPropagation();
			}
		});
		_state.content.addEventListener('mousemove', function (e) {
			if ((e.buttons & 0x01) != 0x01)
				_state.stopToggle();
			else
				_state.moveToggle(e.clientX, e.clientY);
		});
		_state.content.addEventListener('mouseup', function (e) {
			if (e.button != 0) return;
			_state.stopToggle();
			e.preventDefault();
			e.stopPropagation();
		});
		_state.content.addEventListener('touchstart', function (e) {
			if (e.touches.length != 1) _state.stopToggle();
			else if (_state.startToggle(e.touches[0].clientX, e.touches[0].clientY)) {
				e.preventDefault();
				e.stopPropagation();
			}
		});
		_state.content.addEventListener('touchmove', function (e) {
			if (e.touches.length != 1)
				_state.stopToggle();
			else
				_state.moveToggle(e.touches[0].clientX, e.touches[0].clientY);
		});
		_state.content.addEventListener('touchstop', function (e) {
			_state.stopToggle();
			e.preventDefault();
			e.stopPropagation();
		});
	}
	_state.finish = function () {
		document.getElementById("finalize").style.display = 'flex';
		document.getElementById('error').style.display = 'none';
	}
	_state.upload = function () {
		let name = document.getElementById('name').value;

		/* check if an upload is active */
		if (_state.uploading) {
			document.getElementById('error').innerText = 'Uploading...';
			document.getElementById('error').style.display = 'block';
			return;
		}

		/* validate the name length */
		if (name.length == 0 || name.length > 255) {
			document.getElementById('error').innerText = 'Name must be between 1 and 255 characters long';
			document.getElementById('error').style.display = 'block';
			return;
		}

		/* validate the name style */
		if (name[0] == '-' || name[name.length - 1] == '-') {
			document.getElementById('error').innerText = 'Name cannot end on a hyphen';
			document.getElementById('error').style.display = 'block';
			return;
		}
		for (let i = 0; i < name.length; ++i) {
			if (name[i] >= 'a' && name[i] <= 'z') continue;
			if (name[i] >= 'A' && name[i] <= 'Z') continue;
			if (name[i] >= '0' && name[i] <= '9') continue;
			if (name[i] == '-' || name[i] == '_') continue;
			document.getElementById('error').innerText = 'Name can only consist of [a-z][A-Z][0-9][_-]';
			document.getElementById('error').style.display = 'block';
			return;
		}

		/* serialize the grid */
		let out = { width: _state.width, height: _state.height, grid: [] };
		for (let x = 0; x < _state.width; ++x) {
			for (let y = 0; y < _state.width; ++y)
				out.grid.push(_state.grid[x][y].solid);
		}
		document.getElementById("finalize").style.display = 'none';

		/* post the result out */
		let req = new XMLHttpRequest();
		req.onreadystatechange = function () {
			if (req.readyState != 4) return;
			_state.uploading = false;

			/* redirect to the main page */
			if (req.status == 200 || true) {
				document.location = `/crossword/main.html&uploaded=${name}`;
				return;
			}

			/* post the error */
			document.getElementById("finalize").style.display = 'flex';
			document.getElementById('error').innerText = 'Error while uploading the edited crossword...';
			document.getElementById('error').style.display = 'block';
			return;
		};
		req.open("POST", `/crossword/upload/${name}`, true);
		req.setRequestHeader('Content-Type', 'application/json');
		req.send(JSON.stringify(out));

		/* mark a request as being sent */
		_state.uploading = true;
		_state.upload();
	}
	_state.cancel = function () {
		document.getElementById('name').value = '';
		document.getElementById("finalize").style.display = 'none';
	}

	_state.digitize = function () {
		/* rule for digitization: if previous is solid or out of bounds, and next is not, add a digit (both for
		*	horizontal and vertical) and then assign digits from left to right, followed by top to bottom */
		let next = 0;

		/* iterate over the grid from left to right/top to bottom and assign the digits */
		for (let y = 0; y < _state.height; ++y) {
			for (let x = 0; x < _state.width; ++x) {
				/* check if the cell is solid and can be marked as solid and skipped */
				if (_state.grid[x][y].solid) {
					_state.grid[x][y].html.innerText = '';
					_state.grid[x][y].html.classList.add(['solid']);
					continue;
				}
				_state.grid[x][y].html.classList.remove(['solid']);

				/* check if a digit should be added */
				let leftEmpty = (x > 0 && !_state.grid[x - 1][y].solid);
				let topEmpty = (y > 0 && !_state.grid[x][y - 1].solid);
				let rightEmpty = (x + 1 < _state.width && !_state.grid[x + 1][y].solid);
				let bottomEmpty = (y + 1 < _state.height && !_state.grid[x][y + 1].solid);
				if ((leftEmpty || !rightEmpty) && (topEmpty || !bottomEmpty)) {
					_state.grid[x][y].html.innerText = '';
					continue;
				}

				/* select the next digit and add it */
				_state.grid[x][y].html.innerText = `${++next}`;
			}
		}
	}

	_state.startToggle = function (clientX, clientY) {
		/* check if a valid cell has been hit */
		let [x, y] = _state.screenToIndex(clientX, clientY);
		if (x == null || y == null) return false;

		/* setup the operation */
		_state.updating = !_state.grid[x][y].solid;
		_state.toggleSolid(x, y);
		return true;
	}
	_state.moveToggle = function (clientX, clientY) {
		if (_state.updating == null) return;
		let [x, y] = _state.screenToIndex(clientX, clientY);
		_state.toggleSolid(x, y);
	}
	_state.stopToggle = function () {
		_state.updating = null;
	}
	_state.toggleSolid = function (x, y) {
		/* check if the operation is over */
		if (_state.updating == null) return;
		if (x == null || y == null) {
			_state.updating = null;
			return;
		}

		/* check if the value should be updated */
		if (_state.grid[x][y].solid != _state.updating) {
			_state.grid[x][y].solid = _state.updating;
			_state.digitize();
		}
	}
	_state.screenToIndex = function (x, y) {
		/* translate relative to container */
		let rect = _state.container.getBoundingClientRect();
		x -= rect.left;
		y -= rect.top;

		/* apply the view transformation */
		x = (x - _state.view.pos[0]) / _state.view.scale;
		y = (y - _state.view.pos[1]) / _state.view.scale;

		/* map the values to indices (no need to take care of border-width as it is not part of client-dimensions) */
		x = Math.floor((x / _state.content.clientWidth) * _state.width);
		y = Math.floor((y / _state.content.clientHeight) * _state.height);
		if (x < 0 || x >= _state.width || y < 0 || y >= _state.height)
			return [null, null];
		return [x, y];
	}

	_state.updateView = function () {
		/* fetch the dimensions */
		let content = [_state.content.clientWidth, _state.content.clientHeight];
		let world = [_state.container.clientWidth, _state.container.clientHeight];

		/* compute the requested destination position and dimensions */
		let target = [world[0] * (7 / 8), world[1] * (7 / 8)];

		/* compute the scale such that the target is reached along one axis, and the other axis is smaller */
		_state.view.scale = Math.min(target[0] / content[0], target[1] / content[1]);

		/* compute the positions accordingly */
		for (let i = 0; i < 2; ++i)
			_state.view.pos[i] = (world[i] - (content[i] * _state.view.scale)) / 2;

		/* apply the new viewport */
		_state.content.style.transform = `translate(${_state.view.pos[0]}px, ${_state.view.pos[1]}px) scale(${_state.view.scale})`;
	}

</script>