<!-- SPDX-License-Identifier: BSD-3-Clause -->
<!-- Copyright (c) 2025 Bjoern Boss Henrichsen -->
<!DOCTYPE html>
<html lang="en" style="margin: 0; height: 100%;">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Editor</title>
	<link rel="stylesheet" type="text/css" href="/crossword/style.css">
</head>

<body contenteditable="false">
	<!-- dimension screen -->
	<div id="dimensions" class="overlay show">
		<div class="dialog">
			<div class="caption">Dimensions</div>
			<div style="display: flex; flex-direction: row; margin: 15px;">
				<input type="number" placeholder="Width" id="width"
					style="width: 150px; font-size: 1.3em; padding: 4px;" min="1" max="64" value="15">
				<div style="font-size: 1.75em; padding: 0px 10px 5px 10px;">&times;</div>
				<input type="number" placeholder="Height" id="height"
					style="width: 150px; font-size: 1.3em; padding: 4px;" min="1" max="64" value="15">
			</div>
			<div class="confirm">
				<div class="button" style="width: 150px;" onclick="_state.setup()">Create</div>
			</div>
		</div>
	</div>

	<!-- finalize screen -->
	<div id="finalize" class="overlay">
		<div class="dialog">
			<div class="caption">Upload Crossword</div>
			<div style="margin: 15px;">
				<input placeholder="Name" id="name" style="width: 350px; font-size: 1.3em; padding: 4px;">
			</div>
			<div id="error" class="error" style="margin: 0px 15px 15px 15px;">Error Message</div>
			<div style="margin: 0px 15px 15px 15px; font-size: 0.75em;">Note: Uploaded crosswords cannot be modified
				anymore.</div>
			<div class="confirm">
				<div class="button" style="width: 100px;" onclick="_state.upload()">Upload</div>
				<div style="width: 15px;"></div>
				<div class="button" style="width: 100px;" onclick="_state.cancel()">Cancel</div>
			</div>
		</div>
	</div>

	<!-- editor view -->
	<div id="editor" class="main">
		<!-- editor caption -->
		<div class="header">
			<div id="caption" class="caption">Creating a new Crossword!</div>
			<div style="min-width: 20px;"></div>
			<div class="button" onclick="_state.finish();" style="width: 70px;">Finish</div>
		</div>

		<!-- editor view -->
		<div class="content" id="container">
			<div class="grid" id="content" style="display: none;"></div>
		</div>

		<!-- editor footer -->
		<div class="footer">
			Note: Numbers are automatically assigned. Should they not match, please open issue on github.
		</div>
	</div>
</body>

</html>

<script>
	let _state = { uploading: false };
	_state.setup = function () {
		/* validate the dimension */
		_state.width = parseInt(document.getElementById('width').value);
		_state.height = parseInt(document.getElementById('height').value);
		if (!isFinite(_state.width) || !isFinite(_state.height) || _state.width < 0 || _state.width > 64 || _state.height < 0 || _state.height > 64) {
			alert("Invalid dimensions specified");
			return;
		}

		/* lock the input page */
		document.getElementById('dimensions').classList.remove('show');

		/* setup the editor */
		document.getElementById('caption').innerText = `Creating a Crossword of Size: [${_state.width} \u00d7 ${_state.height}]`;
		document.getElementById('content').style.display = 'block';

		/* create the grid object */
		_state.grid = new Array(_state.width);
		for (let x = 0; x < _state.width; ++x) {
			_state.grid[x] = new Array(_state.height);
			for (let y = 0; y < _state.height; ++y)
				_state.grid[x][y] = { solid: false, html: null };
		}

		/* create the separate cells */
		_state.container = document.getElementById('container');
		_state.content = document.getElementById('content');
		for (let y = 0; y < _state.height; ++y) {
			let row = document.createElement('div');
			row.classList.add('row');
			_state.content.appendChild(row);

			/* add all of the cells */
			for (let x = 0; x < _state.width; ++x) {
				let cell = document.createElement('div');
				cell.classList.add('cell');
				row.appendChild(cell);

				/* write the cell to the grid object */
				_state.grid[x][y].html = cell;
			}
		}

		/* digitize the new grid (to add all indices) */
		_state.digitize();

		/* setup the viewport */
		_state.view = { scale: 1, pos: [0, 0] };
		_state.updateView();
		new ResizeObserver(() => _state.updateView()).observe(_state.container);

		/* register the event listeners for updating the grid (by left-click/single touch) */
		_state.updating = null;
		_state.content.addEventListener('mousedown', function (e) {
			if (e.button == 0 && _state.startToggle(e.clientX, e.clientY)) {
				e.preventDefault();
				e.stopPropagation();
			}
		});
		_state.content.addEventListener('mousemove', function (e) {
			if ((e.buttons & 0x01) != 0x01)
				_state.stopToggle();
			else
				_state.moveToggle(e.clientX, e.clientY);
		});
		_state.content.addEventListener('mouseup', function (e) {
			if (e.button != 0) return;
			_state.stopToggle();
			e.preventDefault();
			e.stopPropagation();
		});
		_state.content.addEventListener('touchstart', function (e) {
			if (e.touches.length != 1) _state.stopToggle();
			else if (_state.startToggle(e.touches[0].clientX, e.touches[0].clientY)) {
				e.preventDefault();
				e.stopPropagation();
			}
		});
		_state.content.addEventListener('touchmove', function (e) {
			if (e.touches.length != 1)
				_state.stopToggle();
			else
				_state.moveToggle(e.touches[0].clientX, e.touches[0].clientY);
		});
		_state.content.addEventListener('touchstop', function (e) {
			_state.stopToggle();
			e.preventDefault();
			e.stopPropagation();
		});

		/* register handle to cancel dialogs */
		window.addEventListener('keydown', function (e) {
			if (e.key === 'Escape')
				_state.cancel();
		});
	}
	_state.finish = function () {
		document.getElementById("finalize").classList.add('show');
		document.getElementById('error').classList.remove('show');
	}
	_state.upload = function () {
		let name = document.getElementById('name').value;

		/* check if an upload is active */
		if (_state.uploading) {
			document.getElementById('error').innerText = 'Uploading...';
			document.getElementById('error').classList.add('show');
			return;
		}

		/* validate the name length */
		if (name.length == 0 || name.length > 255) {
			document.getElementById('error').innerText = 'Name must be between 1 and 255 characters long';
			document.getElementById('error').classList.add('show');
			return;
		}

		/* validate the name style */
		for (let i = 0; i < name.length; ++i) {
			if (name[i] >= 'a' && name[i] <= 'z') continue;
			if (name[i] >= 'A' && name[i] <= 'Z') continue;
			if (name[i] >= '0' && name[i] <= '9') continue;
			if (name[i] == '-' || name[i] == '_' || name[i] == '.') {
				if (i != 0 && i != name.length - 1)
					continue;
				document.getElementById('error').innerText = 'Name connot start or end with [._-]';
			}
			else
				document.getElementById('error').innerText = 'Name can only consist of [a-z][A-Z][0-9][._-]';
			document.getElementById('error').classList.add('show');
			return;
		}

		/* serialize the grid */
		let out = { width: _state.width, height: _state.height, grid: [] };
		for (let x = 0; x < _state.width; ++x) {
			for (let y = 0; y < _state.width; ++y)
				out.grid.push(_state.grid[x][y].solid);
		}
		document.getElementById("finalize").classList.remove('show');

		/* post the result out */
		_state.uploading = true;
		fetch(`/crossword/game/${name}`, { method: 'POST', body: JSON.stringify(out), headers: { "Content-Type": 'application/json' } })
			.then(function (resp) {
				/* redirect to the main page */
				if (!resp.ok)
					throw new Error(resp.statusText);
				document.location = `/crossword?uploaded=${name}`;
			}).catch(function (e) {
				/* post the error */
				document.getElementById("finalize").classList.add('show');
				document.getElementById('error').innerText = `Error while uploading the edited crossword: ${e.message}`;
				document.getElementById('error').classList.add('show');
				_state.uploading = false;
			});

		/* mark a request as being sent */
		_state.upload();
	}
	_state.cancel = function () {
		document.getElementById('name').value = '';
		document.getElementById("finalize").classList.remove('show');
	}

	_state.digitize = function () {
		/* rule for digitization: if previous is solid or out of bounds, and next is not, add a digit (both for
		*	horizontal and vertical) and then assign digits from left to right, followed by top to bottom */
		let next = 0;

		/* iterate over the grid from left to right/top to bottom and assign the digits */
		for (let y = 0; y < _state.height; ++y) {
			for (let x = 0; x < _state.width; ++x) {
				/* check if the cell is solid and can be marked as solid and skipped */
				if (_state.grid[x][y].solid) {
					_state.grid[x][y].html.innerText = '';
					_state.grid[x][y].html.classList.add('solid');
					continue;
				}
				_state.grid[x][y].html.classList.remove('solid');

				/* check if a digit should be added */
				let leftEmpty = (x > 0 && !_state.grid[x - 1][y].solid);
				let topEmpty = (y > 0 && !_state.grid[x][y - 1].solid);
				let rightEmpty = (x + 1 < _state.width && !_state.grid[x + 1][y].solid);
				let bottomEmpty = (y + 1 < _state.height && !_state.grid[x][y + 1].solid);
				if ((leftEmpty || !rightEmpty) && (topEmpty || !bottomEmpty)) {
					_state.grid[x][y].html.innerText = '';
					continue;
				}

				/* select the next digit and add it */
				_state.grid[x][y].html.innerText = `${++next}`;
			}
		}
	}

	_state.startToggle = function (clientX, clientY) {
		/* check if a valid cell has been hit */
		let [x, y] = _state.screenToIndex(clientX, clientY);
		if (x == null || y == null) return false;

		/* setup the operation */
		_state.updating = !_state.grid[x][y].solid;
		_state.toggleSolid(x, y);
		return true;
	}
	_state.moveToggle = function (clientX, clientY) {
		if (_state.updating == null) return;
		let [x, y] = _state.screenToIndex(clientX, clientY);
		_state.toggleSolid(x, y);
	}
	_state.stopToggle = function () {
		_state.updating = null;
	}
	_state.toggleSolid = function (x, y) {
		/* check if the operation is over */
		if (_state.updating == null) return;
		if (x == null || y == null) {
			_state.updating = null;
			return;
		}

		/* check if the value should be updated */
		if (_state.grid[x][y].solid != _state.updating) {
			_state.grid[x][y].solid = _state.updating;
			_state.digitize();
		}
	}
	_state.screenToIndex = function (x, y) {
		/* translate relative to container */
		let rect = _state.container.getBoundingClientRect();
		x -= rect.left;
		y -= rect.top;

		/* apply the view transformation */
		x = (x - _state.view.pos[0]) / _state.view.scale;
		y = (y - _state.view.pos[1]) / _state.view.scale;

		/* map the values to indices (no need to take care of border-width as it is not part of client-dimensions) */
		x = Math.floor((x / _state.content.clientWidth) * _state.width);
		y = Math.floor((y / _state.content.clientHeight) * _state.height);
		if (x < 0 || x >= _state.width || y < 0 || y >= _state.height)
			return [null, null];
		return [x, y];
	}

	_state.updateView = function () {
		/* fetch the dimensions */
		let content = [_state.content.clientWidth, _state.content.clientHeight];
		let world = [_state.container.clientWidth, _state.container.clientHeight];

		/* compute the requested destination position and dimensions */
		let target = [world[0] * (7 / 8), world[1] * (7 / 8)];

		/* compute the scale such that the target is reached along one axis, and the other axis is smaller */
		_state.view.scale = Math.min(target[0] / content[0], target[1] / content[1]);

		/* compute the positions accordingly */
		for (let i = 0; i < 2; ++i)
			_state.view.pos[i] = (world[i] - (content[i] * _state.view.scale)) / 2;

		/* apply the new viewport */
		_state.content.style.transform = `translate(${_state.view.pos[0]}px, ${_state.view.pos[1]}px) scale(${_state.view.scale})`;
	}

</script>